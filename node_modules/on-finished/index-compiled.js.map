{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index-compiled.js","sourcesContent":["/*!\n * on-finished\n * Copyright(c) 2013 Jonathan Ong\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = onFinished\nmodule.exports.isFinished = isFinished\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar first = require('ee-first')\n\n/**\n * Variables.\n * @private\n */\n\n/* istanbul ignore next */\nvar defer = typeof setImmediate === 'function'\n  ? setImmediate\n  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }\n\n/**\n * Invoke callback when the response has finished, useful for\n * cleaning up resources afterwards.\n *\n * @param {object} msg\n * @param {function} listener\n * @return {object}\n * @public\n */\n\nfunction onFinished(msg, listener) {\n  if (isFinished(msg) !== false) {\n    defer(listener, null, msg)\n    return msg\n  }\n\n  // attach the listener to the message\n  attachListener(msg, listener)\n\n  return msg\n}\n\n/**\n * Determine if message is already finished.\n *\n * @param {object} msg\n * @return {boolean}\n * @public\n */\n\nfunction isFinished(msg) {\n  var socket = msg.socket\n\n  if (typeof msg.finished === 'boolean') {\n    // OutgoingMessage\n    return Boolean(msg.finished || (socket && !socket.writable))\n  }\n\n  if (typeof msg.complete === 'boolean') {\n    // IncomingMessage\n    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))\n  }\n\n  // don't know\n  return undefined\n}\n\n/**\n * Attach a finished listener to the message.\n *\n * @param {object} msg\n * @param {function} callback\n * @private\n */\n\nfunction attachFinishedListener(msg, callback) {\n  var eeMsg\n  var eeSocket\n  var finished = false\n\n  function onFinish(error) {\n    eeMsg.cancel()\n    eeSocket.cancel()\n\n    finished = true\n    callback(error)\n  }\n\n  // finished on first message event\n  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)\n\n  function onSocket(socket) {\n    // remove listener\n    msg.removeListener('socket', onSocket)\n\n    if (finished) return\n    if (eeMsg !== eeSocket) return\n\n    // finished on first socket event\n    eeSocket = first([[socket, 'error', 'close']], onFinish)\n  }\n\n  if (msg.socket) {\n    // socket already assigned\n    onSocket(msg.socket)\n    return\n  }\n\n  // wait for socket to be assigned\n  msg.on('socket', onSocket)\n\n  if (msg.socket === undefined) {\n    // node.js 0.8 patch\n    patchAssignSocket(msg, onSocket)\n  }\n}\n\n/**\n * Attach the listener to the message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\nfunction attachListener(msg, listener) {\n  var attached = msg.__onFinished\n\n  // create a private single listener with queue\n  if (!attached || !attached.queue) {\n    attached = msg.__onFinished = createListener(msg)\n    attachFinishedListener(msg, attached)\n  }\n\n  attached.queue.push(listener)\n}\n\n/**\n * Create listener on message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\nfunction createListener(msg) {\n  function listener(err) {\n    if (msg.__onFinished === listener) msg.__onFinished = null\n    if (!listener.queue) return\n\n    var queue = listener.queue\n    listener.queue = null\n\n    for (var i = 0; i < queue.length; i++) {\n      queue[i](err, msg)\n    }\n  }\n\n  listener.queue = []\n\n  return listener\n}\n\n/**\n * Patch ServerResponse.prototype.assignSocket for node.js 0.8.\n *\n * @param {ServerResponse} res\n * @param {function} callback\n * @private\n */\n\nfunction patchAssignSocket(res, callback) {\n  var assignSocket = res.assignSocket\n\n  if (typeof assignSocket !== 'function') return\n\n  // res.on('socket', callback) is broken in 0.8\n  res.assignSocket = function _assignSocket(socket) {\n    assignSocket.call(this, socket)\n    callback(socket)\n  }\n}\n"]}